import { Effect, Signal } from "@kixelated/signals";
import { connect } from "./connect.js";
export class Reload {
    url;
    enabled;
    status = new Signal("disconnected");
    established = new Signal(undefined);
    // WebTransport options (not reactive).
    webtransport;
    // WebSocket (fallback) options (not reactive).
    websocket;
    // Not reactive, but can be updated.
    delay;
    signals = new Effect();
    #delay;
    // Increased by 1 each time to trigger a reload.
    #tick = new Signal(0);
    constructor(props) {
        this.url = Signal.from(props?.url);
        this.enabled = Signal.from(props?.enabled ?? false);
        this.delay = props?.delay ?? { initial: 1000, multiplier: 2, max: 30000 };
        this.webtransport = props?.webtransport;
        this.websocket = props?.websocket;
        this.#delay = this.delay.initial;
        // Create a reactive root so cleanup is easier.
        this.signals.effect(this.#connect.bind(this));
    }
    #connect(effect) {
        // Will retry when the tick changes.
        effect.get(this.#tick);
        const enabled = effect.get(this.enabled);
        if (!enabled)
            return;
        const url = effect.get(this.url);
        if (!url)
            return;
        effect.set(this.status, "connecting", "disconnected");
        effect.spawn(async () => {
            try {
                const pending = connect(url, { websocket: this.websocket, webtransport: this.webtransport });
                const connection = await Promise.race([effect.cancel, pending]);
                if (!connection) {
                    pending.then((conn) => conn.close()).catch(() => { });
                    return;
                }
                effect.set(this.established, connection);
                effect.cleanup(() => connection.close());
                effect.set(this.status, "connected", "disconnected");
                // Reset the exponential backoff on success.
                this.#delay = this.delay.initial;
                await Promise.race([effect.cancel, connection.closed]);
            }
            catch (err) {
                console.warn("connection error:", err);
                const tick = this.#tick.peek() + 1;
                effect.timer(() => this.#tick.update((prev) => Math.max(prev, tick)), this.#delay);
                this.#delay = Math.min(this.#delay * this.delay.multiplier, this.delay.max);
            }
        });
    }
    close() {
        this.signals.close();
    }
}
//# sourceMappingURL=reload.js.map